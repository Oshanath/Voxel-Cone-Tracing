#version 450

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Vertex {
    vec4 position;
    vec4 texcoord;
    vec4 normal;
    vec4 tangent;
    vec4 bitangent;
};

layout(set = 0, binding = 0, rgba8) uniform image3D voxelTexture;

layout (set = 1, binding = 0) uniform PerFrameUBO 
{	
	mat4 view;
	mat4 projection;
	vec4 aabb_min;
	vec4 aabb_max;
} ubo;

layout (set = 2, binding = 0) uniform ViewProjUBO 
{	
	mat4 view;
	mat4 proj;
} view_proj;

layout (set = 3, binding = 0) uniform sampler2D s_Diffuse;
layout (set = 3, binding = 1) uniform sampler2D s_Normal;
layout (set = 3, binding = 2) uniform sampler2D s_Metallic;
layout (set = 3, binding = 3) uniform sampler2D s_Roughness;

layout(set = 4, binding = 0) buffer VertexBuffer {
    Vertex vertices[];
};

layout(set = 4, binding = 1) buffer IndexBuffer {
    uint indices[];
};

layout( push_constant ) uniform constants
{
	mat4 model;
    int start_index;
} pc;

bool test_axis(vec3 axis, vec3 u0, vec3 u1, vec3 u2, float extent){
    vec3 A0 = vec3(1.0, 0.0, 0.0);
    vec3 A1 = vec3(0.0, 1.0, 0.0);
    vec3 A2 = vec3(0.0, 0.0, 1.0);

    float p0 = dot(axis, u0);
    float p1 = dot(axis, u1);
    float p2 = dot(axis, u2);
    float R = extent * (abs(dot(A0, axis)) + abs(dot(A1, axis)) + abs(dot(A2, axis)));
    return (min(min(p0, p1), p2) > R || max(max(p0, p1), p2) < -R);
}

bool voxel_triangle_collision_test(vec3 u0, vec3 u1, vec3 u2, ivec3 voxel, float voxel_width, vec3 voxel_grid_min){
    
    float a = voxel_width / 2.0;    // extent
    vec3 e0 = u1 - u0;              // edge 1
    vec3 e1 = u2 - u1;              // edge 2
    vec3 e2 = u2 - u0;              // edge 3
    vec3 n = cross(e0, e1);         // normal
    vec3 c = voxel_grid_min + vec3(voxel) * voxel_width + vec3(a);  // voxel center
    vec3 d = u0 - c;                // vector from triangle to voxel center
    vec3 A0 = vec3(1.0, 0.0, 0.0);
    vec3 A1 = vec3(0.0, 1.0, 0.0);
    vec3 A2 = vec3(0.0, 0.0, 1.0);

    u0 -= c;
    u1 -= c;
    u2 -= c;

    if (test_axis(A0, u0, u1, u2, a)) return false;
    if (test_axis(A1, u0, u1, u2, a)) return false;
    if (test_axis(A2, u0, u1, u2, a)) return false;
    if (test_axis(normalize(cross(A0, e0)), u0, u1, u2, a)) return false;
    if (test_axis(normalize(cross(A0, e1)), u0, u1, u2, a)) return false;
    if (test_axis(normalize(cross(A0, e2)), u0, u1, u2, a)) return false;
    if (test_axis(normalize(cross(A1, e0)), u0, u1, u2, a)) return false;
    if (test_axis(normalize(cross(A1, e1)), u0, u1, u2, a)) return false;
    if (test_axis(normalize(cross(A1, e2)), u0, u1, u2, a)) return false;
    if (test_axis(normalize(cross(A2, e0)), u0, u1, u2, a)) return false;
    if (test_axis(normalize(cross(A2, e1)), u0, u1, u2, a)) return false;
    if (test_axis(normalize(cross(A2, e2)), u0, u1, u2, a)) return false;
    if (test_axis(normalize(n), u0, u1, u2, a)) return false;
    return true;
}

void main()
{
    uint index = gl_GlobalInvocationID.x;
    
    #define vertex1 vertices[indices[pc.start_index + index * 3]]
    #define vertex2 vertices[indices[pc.start_index + index * 3 + 1]]
    #define vertex3 vertices[indices[pc.start_index + index * 3 + 2]]

    vec3 _min = ubo.aabb_min.xyz;
	vec3 _max = ubo.aabb_max.xyz;
    int voxels_per_side = imageSize(voxelTexture).x;
    float voxel_width = (_max.x - _min.x) / float(voxels_per_side);

    vec4 vertex1_world = pc.model * vertex1.position;
    vec4 vertex2_world = pc.model * vertex2.position;
    vec4 vertex3_world = pc.model * vertex3.position;
    
    ivec3 vertex1_voxel = ivec3((vertex1_world.xyz - _min) / voxel_width);
    ivec3 vertex2_voxel = ivec3((vertex2_world.xyz - _min) / voxel_width);
    ivec3 vertex3_voxel = ivec3((vertex3_world.xyz - _min) / voxel_width);

    // Loop over the voxels in the bounding box of the triangle
    for(uint i = min(min(vertex1_voxel.x, vertex2_voxel.x), vertex3_voxel.x); i <= max(max(vertex1_voxel.x, vertex2_voxel.x), vertex3_voxel.x); i++){
        for(uint j = min(min(vertex1_voxel.y, vertex2_voxel.y), vertex3_voxel.y); j <= max(max(vertex1_voxel.y, vertex2_voxel.y), vertex3_voxel.y); j++){
            for(uint k = min(min(vertex1_voxel.z, vertex2_voxel.z), vertex3_voxel.z); k <= max(max(vertex1_voxel.z, vertex2_voxel.z), vertex3_voxel.z); k++){
                if (voxel_triangle_collision_test(vertex1_world.xyz, vertex2_world.xyz, vertex3_world.xyz, ivec3(i, j, k), voxel_width, _min)){
                    
                    vec2 texcoord = (vertex1.texcoord.xy + vertex2.texcoord.xy + vertex3.texcoord.xy) / 3.0;
                    
                    vec3 diffuse = texture(s_Diffuse, texcoord).xyz;
                    const vec4 current_voxel_value = imageLoad(voxelTexture, ivec3(i, j, k));
                    const vec4 voxel_value = vec4(current_voxel_value.xyz + diffuse, current_voxel_value.w + 1.0);
                    imageStore(voxelTexture, ivec3(i, j, k), voxel_value);
                }
            }
        }
    }
    
}
