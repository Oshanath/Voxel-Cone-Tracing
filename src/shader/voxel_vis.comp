#version 450

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(set = 0, binding = 0, rgba8) uniform image3D voxelTexture;

layout(std140, set=1, binding = 0) buffer InstanceBuffer {
   vec4 positions[];
};

struct VkDrawIndexedIndirectCommand {
    uint    indexCount;
    uint    instanceCount;
    uint    firstIndex;
    int     vertexOffset;
    uint    firstInstance;
};

layout(std140, set=2, binding = 0) buffer IndirectBuffer {
   VkDrawIndexedIndirectCommand command;
};

layout (set = 3, binding = 0) uniform PerFrameUBO 
{	
	mat4 view;
	mat4 projection;
	vec4 aabb_min;
	vec3 aabb_max;
} ubo;

void main()
{

    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    uint z = gl_GlobalInvocationID.z;
    ivec3 voxel_coordinate = ivec3(x, y, z);

    vec4 voxel_value = imageLoad(voxelTexture, voxel_coordinate);

    if(voxel_value.x > 0.5)
	{
		uint index = atomicAdd(command.instanceCount, 1);

        vec3 _min = ubo.aabb_min.xyz;
	    vec3 _max = ubo.aabb_max.xyz;
	    int voxels_per_side = int(ubo.aabb_min.w);
	    mat4 grid_space_transformation = ubo.projection * ubo.view;
        mat4 inverse_grid_space_transformation = inverse(grid_space_transformation);
        vec4 min_grid_space = grid_space_transformation * vec4(_min, 1.0);
	    vec4 max_grid_space = grid_space_transformation * vec4(_max, 1.0);

        float voxel_width = (min_grid_space.x - max_grid_space.x) / voxels_per_side;
        vec3 grid_space_position = min_grid_space.xyz + vec3(voxel_width / 2) + vec3(voxel_coordinate) * voxel_width;
        vec4 world_space_position = inverse_grid_space_transformation * vec4(grid_space_position, 1.0);
        positions[index] = world_space_position;
	}
}